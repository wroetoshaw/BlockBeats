var e=require("isomorphic-unfetch"),r=require("stream"),t=require("lodash.merge"),s=require("user-agents");function a(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var n=a(e),i=a(r),o=a(t),u=a(s);function l(e,r){r.fallbackUrl.trim()?e.redirect(r.fallbackUrl):e.status(422).send({message:r.messages.imageFetchError})}exports.withImageProxy=function(e){var t=o.default({whitelistedPatterns:[],fallbackUrl:"",messages:{wrongFormat:"Image url not provided or has wrong format",notWhitelisted:"Provided image url is not whitelisted",imageFetchError:"Couldn't fetch the image"}},e);return function(e,s){try{var a=e.query.imageUrl;return!a||a&&Array.isArray(a)?(s.status(400).send({message:t.messages.wrongFormat}),Promise.resolve()):(o=a,t.whitelistedPatterns.some(function(e){return o.match(e)})?Promise.resolve(function(e){try{return Promise.resolve(n.default(e,{headers:{"user-agent":(new u.default).toString()}}).then(function(e){return e.body}))}catch(e){return Promise.reject(e)}}(a)).then(function(e){e?function(e,t,s){var a=new r.Stream.PassThrough;i.default.pipeline(t,a,function(r){if(r)return console.log(r),void l(e,s)}),a.pipe(e)}(s,e,t):l(s,t)}):(s.status(422).send({message:t.messages.notWhitelisted}),Promise.resolve()))}catch(e){return Promise.reject(e)}var o}};
//# sourceMappingURL=next-image-proxy.js.map
